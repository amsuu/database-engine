import 'zx/globals';

import _ from "lodash";
import { core, parse } from "@interslavic/steen-utils";

import razumlivost from '../dist/index.js';

import { LANGS } from "./utils/constants.mjs";
import * as csv from './utils/csv.mjs';
import { loadDictionary } from "./utils/hunspell.mjs";

const odometer = new razumlivost.Odometer({
  ignoreCase: true,
  ignoreNonLetters: true,
  ignoreDiacritics: true,
  extractValue: lemma => lemma.value,
});

const flavorizers = razumlivost.flavorizers.slow;
const quickFlavorizers = razumlivost.flavorizers.quick;

await fs.mkdirp('__fixtures__/analysis');
await main('uk'); // process.argv[3]);

async function main(targetLang) {
  const words = await parseNewInterslavicWordsList();
  for (const lang of (targetLang ? [targetLang] : LANGS)) {
    console.log(`Analysing language: ${chalk.yellow(lang)}`);

    const hunspell = await loadDictionary(lang);
    const records = await parseIntelligiblitySheet(words, lang);

    let i = 0;
    for (const word of Object.values(words)) {
      console.log(`Processed ${i++} words.`);

      const record = records[word.id] || {
        id: word.id,
        isv: word.isv,
        translationOriginal: word[lang],
        translationCorrection: new core.Synset({ autogenerated: false }),
        translationMatch: new core.Synset(),
        helperWords: new core.Synset(),
        falseFriends: new core.Synset(),
        flavorization: new core.Synset(),
      };

      const slow = flavorizers[lang];
      const quick = quickFlavorizers[lang];
      const translation = record.translationCorrection.empty
        ? record.translationOriginal
        : record.translationCorrection;

      if (record.flavorization.meta.autogenerated) {
        let flavorization;
        try {
          flavorization = slow.flavorize(word, record.isv);
        } catch (e) {
          console.log(chalk.yellow(`Lemma #${record.id} failed: ${record.isv}`));
          flavorization = quick.flavorize(word, record.isv);
        }

        let similar = odometer.compare(flavorization.lemmas(), translation.lemmas());

        if (similar.editingDistancePercent >= 35) {
          let fallback = [...flavorization.lemmas()].filter(l => hunspell.spellSync(l.value));
          if (!fallback.length) {
            fallback = [...quick.flavorize(word, word.isv).lemmas()];
          }

          similar = odometer.compare(fallback, translation.lemmas());
        } else if (similar.editingDistancePercent === 0) {
          record.flavorization.meta.autogenerated = false;
        }

        record.flavorization.clear().add(similar.query);
      }

      record.translationMatch = translation.intersection(
        record.flavorization,
        (a, b) => odometer.compare([a], [b]).editingDistancePercent <= 33
      );

      record.helperWords = record.helperWords.intersection(
        record.flavorization,
        (a, b) => odometer.compare([a], [b]).editingDistancePercent <= 33
      );

      record.helperWords = record.helperWords.difference(record.translationMatch);
      if (record.helperWords.empty && !record.translationMatch.empty) {
        record.helperWords.meta.autogenerated = false;
      }

      records[word.id] = {
        id: record.id,
        isv: word.raw.isv,
        translationOriginal: word.raw[lang],
        translationCorrection: record.translationCorrection.toString(),
        translationMatch: record.translationMatch.toString(),
        helperWords: record.helperWords.toString(),
        falseFriends: record.falseFriends.toString(),
        flavorization: record.flavorization.toString(),
      };
    }

    const sorted = _.sortBy(records, r => +r.id);
    await csv.writeFile(`__fixtures__/analysis/${lang}.csv`, sorted);
  }
}

async function parseNewInterslavicWordsList() {
  const rawWords = await csv.parseFile(`__fixtures__/words.csv`);

  const words = rawWords.map((word) => {
    const result = {};
    result.raw = word;
    result.id = word.id;
    result.partOfSpeech = parse.partOfSpeech(word.partOfSpeech);
    result.genesis = word.genesis ? parse.genesis(word.genesis) : undefined;

    const isPhrase = word.partOfSpeech.name === 'phrase';
    for (const lang of ['isv', ...LANGS]) {
      result[lang] = parse.synset(word[lang] || '', { isPhrase })
    }

    return result;
  });

  return toPlainMap(words);
}

async function parseIntelligiblitySheet(words, lang) {
  const analysisPath = `__fixtures__/analysis/${lang}.csv`;
  if (!analysisPath) {
    return {};
  }

  const rawAnalysis = await csv.parseFile(analysisPath);
  const analysis = rawAnalysis.map((record) => {
    const { id } = record;
    const opts = {
      isPhrase: words[id].partOfSpeech.name === 'phrase',
    };

    return {
      id,
      isv: words[id].isv,
      translationOriginal: words[id][lang],
      translationCorrection: parse.synset(record.translationCorrection, opts),
      translationMatch: parse.synset(record.translationMatch, opts),
      helperWords: parse.synset(record.helperWords, opts),
      falseFriends: parse.synset(record.falseFriends, opts),
      flavorization: parse.synset(record.flavorization, opts),
    };
  });

  return toPlainMap(analysis);
}

function toPlainMap(rows) {
  return rows.reduce((map, row) => {
    map[row.id] = row;
    return map;
  }, {});
}

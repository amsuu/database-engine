/*

1. Download `new_interslavic_words_list` from Google Sheets.
2. Ensures that `analysis/<lang>.csv` are present for all the Slavic languages.
3. Reads the content of the files and merges with the new words from the sheets.
4. Writes that down.
5. For every unverified column value, runs the automatic checks.
6. Writes that down.
7. Patches the words list column (sameInLanguages).
8. Updates the real Google Sheets.

*/

import 'zx/globals';

import _ from "lodash";
import { core, parse } from "@interslavic/steen-utils";

import { GIDs, LANGS, SHEET_URLS } from "./utils/constants.mjs";
import * as csv from './utils/csv.mjs';
import { redownloadSheet } from './utils/gsheets.mjs';
import { loadDictionary } from "./utils/hunspell.mjs";
import { flavorizers } from "../dist/index.js";

if (!argv.offline) {
  await downloadWordsList();
  await downloadAnalysisSheets();
}

await updateAnalysisSheets(); // and save
// await patchWordsListSameInLanguages();
// await uploadWordsList();

async function downloadWordsList() {
  await fs.mkdirp('__fixtures__');
  await redownloadSheet(`__fixtures__/words.csv`, SHEET_URLS.new_interslavic_words_list, GIDs.new_interslavic_words_list.words);
}

async function downloadAnalysisSheets() {
  await fs.mkdirp('__fixtures__/analysis');
  for (const lang of LANGS) {
    await redownloadSheet(`__fixtures__/analysis/${lang}.csv`, SHEET_URLS.analysis, GIDs.analysis[lang]);
  }
}

async function updateAnalysisSheets() {
  const rawWords = await csv.parseFile(`__fixtures__/words.csv`);
  const wordsMap = rawWords.reduce(toWordsMap, new Map());

  for (const lang of LANGS) {
    console.log('Updating ' + chalk.yellow(lang) + '...');
    const hunspell = await loadDictionary(lang);

    const rawAnalysis = await csv.parseFile(`__fixtures__/analysis/${lang}.csv`, { silent: true });
    const context = { words: wordsMap, lang };
    const analysisMap = rawAnalysis.reduce(toAnalysisMap.bind(context), new Map());
    [...wordsMap.values()].reduce(addToAnalysis.bind(context), analysisMap);

    for (const analysis of analysisMap.values()) {
      if (analysis.disabled) {
        continue;
      }

      if (analysis.flavorization.meta.autogenerated) {
        analysis.flavorization = flavorizers.quick[lang].flavorize(analysis, analysis.isv);
      }

      if (analysis.translationMatch.meta.autogenerated) {
        // update it
      }

      if (analysis.helperWords.meta.autogenerated) {
        // update it
      }

      if (analysis.falseFriends.meta.autogenerated) {
        // update it
      }
    }

    const sortedAnalysis = _.sortBy([...analysisMap.values()], r => parseInt(r.id, 10));
    for (const record of sortedAnalysis) {
      for (const p in record) {
        if (typeof record[p] === 'object') {
          record[p] = record[p].toString();
        }
      }
    }

    await csv.writeFile(`__fixtures__/analysis/${lang}.csv`, sortedAnalysis);
  }
}

/**
 * @param {Map} map
 * @param raw
 * @returns {Map}
 */
function toWordsMap(map, raw) {
  const word = {
    id: raw.id,
    partOfSpeech: parse.partOfSpeech(raw.partOfSpeech),
    genesis: raw.genesis ? parse.genesis(raw.genesis) : undefined,
  };

  Object.defineProperty(word, 'raw', { enumerable: false, value: raw });

  const isPhrase = raw.partOfSpeech.name === 'phrase';
  for (const lang of ['isv', ...LANGS]) {
    word[lang] = parse.synset(raw[lang], { isPhrase })
  }

  map.set(word.id, word);
  return map;
}

/**
 * @this {{ words: Map; lang: string; }}
 * @param {Map} map
 */
function toAnalysisMap(map, raw) {
  const analysis = Object.defineProperty({ ...raw }, 'raw', { enumerable: false, value: raw });
  const original = this.words.get(raw.id);

  if (!original) {
    Object.defineProperty(raw, 'disabled', { enumerable: false, value: true });
  } else {
    const opts = { isPhrase: original.partOfSpeech.name === 'phrase' };

    analysis.isv = original.isv;
    analysis.translationOriginal = original[this.lang];
    analysis.translationMatch = parse.synset(raw.translationMatch, opts);
    analysis.helperWords = parse.synset(raw.helperWords, opts);
    analysis.falseFriends = parse.synset(raw.falseFriends, opts);
    analysis.flavorization = parse.synset(raw.flavorization, opts);
    Object.defineProperty(analysis, 'genesis', { enumerable: false, value: original.genesis });
    Object.defineProperty(analysis, 'partOfSpeech', { enumerable: false, value: original.partOfSpeech });
  }

  return map.set(analysis.id, analysis);
}

/**
 * @this {{ words: Map; lang: string; }}
 * @param {Map} map
 */
function addToAnalysis(map, word) {
  if (map.has(word.id)) {
    return map;
  }

  const analysis = {};
  analysis.id = word.id;
  analysis.isv = word.isv;
  analysis.translationOriginal = word[this.lang];
  analysis.translationCorrection = '';
  analysis.translationMatch = new core.Synset({ autogenerated: true });
  analysis.helperWords = new core.Synset({ autogenerated: true });
  analysis.falseFriends = new core.Synset({ autogenerated: true });
  analysis.flavorization = new core.Synset({ autogenerated: true });

  Object.defineProperty(analysis, 'genesis', { enumerable: false, value: word.genesis });
  Object.defineProperty(analysis, 'partOfSpeech', { enumerable: false, value: word.partOfSpeech });

  return map.set(analysis.id, analysis);
}
